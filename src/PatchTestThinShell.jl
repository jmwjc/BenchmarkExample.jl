module PatchTestThinShell

import ..BenchmarkExample
import Gmsh: gmsh
import Tensors: â‹…, âŠ—, Ã—, âŠ¡, Vec, Tensor, SymmetricTensor, gradient, divergence, curl

ğ¸ = 1.0
ğœˆ = 0.0
ğ‘… = 1.0
# ğœƒ = 0.1*Ï€
ğœƒ = 1.0
ğ¿ = ğ‘…*ğœƒ
â„ = 0.05
# â„ = 12.0^0.5

function variables(cs::Function,ğ’–::Function)
    function âˆ‡ğ’–(x)
        x_ = Vec{3}((x[1],x[2],0.0))
        gradient(ğ’–,x_)
    end
    function âˆ‡Â²ğ’–(x)
        x_ = Vec{3}((x[1],x[2],0.0))
        gradient(âˆ‡ğ’–,x_)
    end
    function ğœº(x)
        gradğ’– = âˆ‡ğ’–(x)
        âˆ‚â‚ğ’– = Tensor{1,3}((gradğ’–[:,1]))
        âˆ‚â‚‚ğ’– = Tensor{1,3}((gradğ’–[:,2]))
        Îµâ‚â‚ = cs.ğ’‚â‚(x)â‹…âˆ‚â‚ğ’–
        Îµâ‚‚â‚‚ = cs.ğ’‚â‚‚(x)â‹…âˆ‚â‚‚ğ’–
        Îµâ‚â‚‚ = 0.5*(cs.ğ’‚â‚(x)â‹…âˆ‚â‚‚ğ’– + cs.ğ’‚â‚‚(x)â‹…âˆ‚â‚ğ’–)
        return Tensor{2,2}((Îµâ‚â‚,Îµâ‚â‚‚,Îµâ‚â‚‚,Îµâ‚‚â‚‚))
    end
    function ğœ¿(x)
        gradğ’– = âˆ‡ğ’–(x)
        grad2ğ’– = âˆ‡Â²ğ’–(x)
        âˆ‚â‚ğ’– = Tensor{1,3}((gradğ’–[:,1]))
        âˆ‚â‚‚ğ’– = Tensor{1,3}((gradğ’–[:,2]))
        âˆ‚â‚â‚ğ’– = Tensor{1,3}((grad2ğ’–[:,1,1]))
        âˆ‚â‚‚â‚‚ğ’– = Tensor{1,3}((grad2ğ’–[:,2,2]))
        âˆ‚â‚â‚‚ğ’– = Tensor{1,3}((grad2ğ’–[:,1,2]))
        Î“Â¹â‚â‚ = cs.Î“Â¹â‚â‚(x)
        Î“Â¹â‚â‚‚ = cs.Î“Â¹â‚â‚‚(x)
        Î“Â¹â‚‚â‚‚ = cs.Î“Â¹â‚‚â‚‚(x)
        Î“Â²â‚â‚ = cs.Î“Â²â‚â‚(x)
        Î“Â²â‚â‚‚ = cs.Î“Â²â‚â‚‚(x)
        Î“Â²â‚‚â‚‚ = cs.Î“Â²â‚‚â‚‚(x)
        ğ’‚â‚ƒ = cs.ğ’‚â‚ƒ(x)
        Îºâ‚â‚ = (Î“Â¹â‚â‚.*âˆ‚â‚ğ’–+Î“Â²â‚â‚.*âˆ‚â‚‚ğ’– - âˆ‚â‚â‚ğ’–)â‹…ğ’‚â‚ƒ
        Îºâ‚‚â‚‚ = (Î“Â¹â‚‚â‚‚.*âˆ‚â‚ğ’–+Î“Â²â‚‚â‚‚.*âˆ‚â‚‚ğ’– - âˆ‚â‚‚â‚‚ğ’–)â‹…ğ’‚â‚ƒ
        Îºâ‚â‚‚ = (Î“Â¹â‚â‚‚.*âˆ‚â‚ğ’–+Î“Â²â‚â‚‚.*âˆ‚â‚‚ğ’– - âˆ‚â‚â‚‚ğ’–)â‹…ğ’‚â‚ƒ
        return Tensor{2,2}((Îºâ‚â‚,Îºâ‚â‚‚,Îºâ‚â‚‚,Îºâ‚‚â‚‚))
    end
    function ğ‘ª(x)
        aÂ¹Â¹ = cs.aÂ¹Â¹(x)
        aÂ²Â² = cs.aÂ²Â²(x)
        aÂ¹Â² = cs.aÂ¹Â²(x)
        CÂ¹Â¹Â¹Â¹ = aÂ¹Â¹*aÂ¹Â¹
        CÂ²Â²Â²Â² = aÂ²Â²*aÂ²Â²
        CÂ¹Â¹Â²Â² = ğœˆ*aÂ¹Â¹*aÂ²Â² + (1-ğœˆ)*aÂ¹Â²*aÂ¹Â²
        CÂ¹Â¹Â¹Â² = aÂ¹Â¹*aÂ¹Â²
        CÂ²Â²Â¹Â² = aÂ²Â²*aÂ¹Â²
        CÂ¹Â²Â¹Â² = 0.5*((1-ğœˆ)*aÂ¹Â¹*aÂ²Â² + (1+ğœˆ)*aÂ¹Â²*aÂ¹Â²)
        return SymmetricTensor{4,2}((CÂ¹Â¹Â¹Â¹,CÂ¹Â¹Â¹Â²,CÂ¹Â¹Â²Â²,CÂ¹Â¹Â¹Â²,CÂ¹Â²Â¹Â²,CÂ²Â²Â¹Â²,CÂ¹Â¹Â²Â²,CÂ²Â²Â¹Â²,CÂ²Â²Â²Â²))
    end
    function ğ‘µ(x)
        Dáµ = ğ¸*â„
        Îµ = ğœº(x)
        C = ğ‘ª(x)
        return Tensor{2,2}((Dáµ.*(C âŠ¡ Îµ)))
    end
    function ğ‘´(x)
        Dáµ‡ = ğ¸*â„^3/12
        Îº = ğœ¿(x)
        C = ğ‘ª(x)
        return Tensor{2,2}((Dáµ‡.*(C âŠ¡ Îº)))
    end
    function ğœƒâ‚™(x,nÂ¹,nÂ²)
        ğ’‚â‚ƒ = cs.ğ’‚â‚ƒ(x)
        gradğ’– = âˆ‡ğ’–(x)
        âˆ‚â‚ğ’– = Tensor{1,3}((gradğ’–[:,1]))
        âˆ‚â‚‚ğ’– = Tensor{1,3}((gradğ’–[:,2]))
        return (nÂ¹.*âˆ‚â‚ğ’– + nÂ².*âˆ‚â‚‚ğ’–)â‹…ğ’‚â‚ƒ
    end
    function ğ’ƒ(x)
        ğ’‚â‚ = cs.ğ’‚â‚(x)
        ğ’‚â‚‚ = cs.ğ’‚â‚‚(x)
        ğ’‚â‚ƒ = cs.ğ’‚â‚ƒ(x)
        bâ‚â‚ = cs.bâ‚â‚(x)
        bâ‚‚â‚‚ = cs.bâ‚‚â‚‚(x)
        bâ‚â‚‚ = cs.bâ‚â‚‚(x)
        function âˆ‡ğ’‚â‚ƒ_(x_)
            x__ = Vec{3}((x_[1],x_[2],0.0))
            return gradient(cs.ğ’‚â‚ƒ,x__)
        end
        âˆ‡ğ’‚â‚ƒ = âˆ‡ğ’‚â‚ƒ_(x)
        x__ = Vec{3}((x[1],x[2],0.0))
        âˆ‡Â²ğ’‚â‚ƒ = gradient(âˆ‡ğ’‚â‚ƒ_,x__)
        âˆ‚â‚ğ’‚â‚ƒ = âˆ‡ğ’‚â‚ƒ_(x)[:,1]
        âˆ‚â‚‚ğ’‚â‚ƒ = âˆ‡ğ’‚â‚ƒ_(x)[:,2]
        Î“Â¹â‚â‚ = cs.Î“Â¹â‚â‚(x)
        Î“Â¹â‚â‚‚ = cs.Î“Â¹â‚â‚‚(x)
        Î“Â¹â‚‚â‚‚ = cs.Î“Â¹â‚‚â‚‚(x)
        Î“Â²â‚â‚ = cs.Î“Â²â‚â‚(x)
        Î“Â²â‚‚â‚ = cs.Î“Â²â‚â‚‚(x)
        Î“Â²â‚‚â‚‚ = cs.Î“Â²â‚‚â‚‚(x)
        âˆ‚â‚Î“Â¹â‚â‚ = cs.âˆ‚â‚Î“Â¹â‚â‚(x)
        âˆ‚â‚‚Î“Â¹â‚â‚ = cs.âˆ‚â‚‚Î“Â¹â‚â‚(x)
        âˆ‚â‚Î“Â¹â‚â‚‚ = cs.âˆ‚â‚Î“Â¹â‚â‚‚(x)
        âˆ‚â‚‚Î“Â¹â‚â‚‚ = cs.âˆ‚â‚‚Î“Â¹â‚â‚‚(x)
        âˆ‚â‚Î“Â¹â‚‚â‚‚ = cs.âˆ‚â‚Î“Â¹â‚‚â‚‚(x)
        âˆ‚â‚‚Î“Â¹â‚‚â‚‚ = cs.âˆ‚â‚‚Î“Â¹â‚‚â‚‚(x)
        âˆ‚â‚Î“Â²â‚â‚ = cs.âˆ‚â‚Î“Â²â‚â‚(x)
        âˆ‚â‚‚Î“Â²â‚â‚ = cs.âˆ‚â‚‚Î“Â²â‚â‚(x)
        âˆ‚â‚Î“Â²â‚â‚‚ = cs.âˆ‚â‚Î“Â²â‚â‚‚(x)
        âˆ‚â‚‚Î“Â²â‚â‚‚ = cs.âˆ‚â‚‚Î“Â²â‚â‚‚(x)
        âˆ‚â‚Î“Â²â‚‚â‚‚ = cs.âˆ‚â‚Î“Â²â‚‚â‚‚(x)
        âˆ‚â‚‚Î“Â²â‚‚â‚‚ = cs.âˆ‚â‚‚Î“Â²â‚‚â‚‚(x)
        Î“Â¹ = Tensor{2,2}((Î“Â¹â‚â‚,Î“Â¹â‚â‚‚,Î“Â¹â‚â‚‚,Î“Â¹â‚‚â‚‚))
        Î“Â² = Tensor{2,2}((Î“Â²â‚â‚,Î“Â²â‚‚â‚,Î“Â²â‚‚â‚,Î“Â²â‚‚â‚‚))
        b = Tensor{2,2}((bâ‚â‚,bâ‚â‚‚,bâ‚â‚‚,bâ‚‚â‚‚))
        Î“áµáµ§ = Vec{2}((Î“Â¹â‚â‚+Î“Â²â‚‚â‚,Î“Â¹â‚â‚‚+Î“Â²â‚‚â‚‚))
        âˆ‚áµ§Î“áµ = Tensor{2,2}((âˆ‚â‚Î“Â¹â‚â‚+âˆ‚â‚‚Î“Â²â‚â‚,âˆ‚â‚Î“Â¹â‚â‚‚+âˆ‚â‚‚Î“Â²â‚â‚‚,âˆ‚â‚Î“Â¹â‚â‚‚+âˆ‚â‚‚Î“Â²â‚â‚‚,âˆ‚â‚Î“Â¹â‚‚â‚‚+âˆ‚â‚‚Î“Â²â‚‚â‚‚))
        âˆ‚Î“áµáµ§ = Tensor{2,2}((âˆ‚â‚Î“Â¹â‚â‚+âˆ‚â‚Î“Â²â‚â‚‚,âˆ‚â‚‚Î“Â¹â‚â‚+âˆ‚â‚‚Î“Â²â‚â‚‚,âˆ‚â‚Î“Â¹â‚â‚‚+âˆ‚â‚Î“Â²â‚‚â‚‚,âˆ‚â‚‚Î“Â¹â‚â‚‚+âˆ‚â‚‚Î“Â²â‚‚â‚‚))
        N = ğ‘µ(x)
        âˆ‡N = gradient(ğ‘µ,x)
        divN = âˆ‡N[:,1,1] + âˆ‡N[:,2,2]
        NÎ“áµáµ§ = N â‹… Î“áµáµ§
        M = ğ‘´(x)
        âˆ‡ğ‘´(x_) = gradient(ğ‘´,x_)
        âˆ‡M = âˆ‡ğ‘´(x)
        âˆ‚â‚ğ‘´(x_) = Tensor{2,2}(âˆ‡ğ‘´(x_)[:,:,1])
        âˆ‚â‚‚ğ‘´(x_) = Tensor{2,2}(âˆ‡ğ‘´(x_)[:,:,2])
        âˆ‚â‚M = âˆ‚â‚ğ‘´(x)
        âˆ‚â‚‚M = âˆ‚â‚‚ğ‘´(x)
        âˆ‡âˆ‚â‚ğ‘´(x_) = gradient(âˆ‚â‚ğ‘´,x_)
        âˆ‡âˆ‚â‚‚ğ‘´(x_) = gradient(âˆ‚â‚‚ğ‘´,x_)
        âˆ‡âˆ‚â‚M = âˆ‡âˆ‚â‚ğ‘´(x)
        âˆ‡âˆ‚â‚‚M = âˆ‡âˆ‚â‚‚ğ‘´(x)
        divM = âˆ‡M[:,1,1] + âˆ‡M[:,2,2]
        div2M = âˆ‡âˆ‚â‚M[1,1,1]+âˆ‡âˆ‚â‚‚M[2,1,1]+âˆ‡âˆ‚â‚M[1,2,2]+âˆ‡âˆ‚â‚‚M[2,2,2]
        âˆ‡Â²ğ’‚â‚ƒM = âˆ‡Â²ğ’‚â‚ƒ[:,1,1]*M[1,1]+âˆ‡Â²ğ’‚â‚ƒ[:,1,2]*M[1,2]+âˆ‡Â²ğ’‚â‚ƒ[:,2,1]*M[2,1]+âˆ‡Â²ğ’‚â‚ƒ[:,2,2]*M[2,2]
        Î“áµáµ§M = Î“áµáµ§â‹…M
        ğ’ƒ1 = (Î“Â¹ âŠ¡ N + divN[1] + NÎ“áµáµ§[1]).*ğ’‚â‚ + (Î“Â² âŠ¡ N + divN[2] + NÎ“áµáµ§[2]).*ğ’‚â‚‚ + b âŠ¡ N.*ğ’‚â‚ƒ
        ğ’ƒ2 = (âˆ‚áµ§Î“áµ âŠ¡ M .*ğ’‚â‚ƒ + Î“Â¹ âŠ¡ M .* âˆ‚â‚ğ’‚â‚ƒ + Î“Â¹ âŠ¡ âˆ‚â‚M .* ğ’‚â‚ƒ + Î“Â² âŠ¡ M .* âˆ‚â‚‚ğ’‚â‚ƒ + Î“Â² âŠ¡ âˆ‚â‚‚M .* ğ’‚â‚ƒ
           + Î“áµáµ§[1]*(Î“Â¹ âŠ¡ M) .* ğ’‚â‚ƒ + Î“áµáµ§[2]*(Î“Â² âŠ¡ M) .* ğ’‚â‚ƒ + div2M.*ğ’‚â‚ƒ + 2*(âˆ‡ğ’‚â‚ƒ[:,1].*divM[1] + âˆ‡ğ’‚â‚ƒ[:,2].*divM[2]) + âˆ‡Â²ğ’‚â‚ƒM + âˆ‚Î“áµáµ§ âŠ¡ M .* ğ’‚â‚ƒ
           + 2*(âˆ‡ğ’‚â‚ƒ[:,1].*Î“áµáµ§M[1]+âˆ‡ğ’‚â‚ƒ[:,2].*Î“áµáµ§M[2] + Î“áµáµ§â‹…divM.*ğ’‚â‚ƒ) + Î“áµáµ§â‹…Mâ‹…Î“áµáµ§.*ğ’‚â‚ƒ)
        return -ğ’ƒ1-ğ’ƒ2
        # return -ğ’ƒ1
        # return -ğ’ƒ2
    end
    return ()->(
        ğœƒâ‚™;ğ‘ª;ğœº;ğœ¿;ğ‘µ;ğ‘´;ğ’ƒ;âˆ‡ğ’–;
    )
end

function generateMsh(filepath::String; lc = 1.0, order = 1, quad = false)
    gmsh.initialize()
    gmsh.model.add("Patch Test")

    Î© = generateGeo(lc)

    if quad
        gmsh.model.mesh.setRecombine(2, Î©)
    end
    
    gmsh.model.mesh.setAlgorithm(2, Î©, 1)
    gmsh.model.mesh.generate(2)
    gmsh.model.mesh.setOrder(order)
    tag = BenchmarkExample.addEdgeElements((2,1), order)
    gmsh.model.geo.addPhysicalGroup(1, [tag], -1, "Î“")
    gmsh.model.geo.synchronize()
    gmsh.write(filepath)
    gmsh.finalize()
end

@inline function generateGeo(lc = 1.0)
    gmsh.model.geo.addPoint(0.0, 0.0, 0.0, lc, 1)
    gmsh.model.geo.addPoint(ğ‘…*ğœƒ, 0.0, 0.0, lc, 2)
    gmsh.model.geo.addPoint(ğ‘…*ğœƒ,  ğ¿, 0.0, lc, 3)
    gmsh.model.geo.addPoint(0.0, ğ¿, 0.0, lc, 4)
    gmsh.model.geo.addLine(1, 2, 1)
    gmsh.model.geo.addLine(2, 3, 2)
    gmsh.model.geo.addLine(3, 4, 3)
    gmsh.model.geo.addLine(4, 1, 4)
    gmsh.model.geo.addCurveLoop([1,2,3,4],1)
    Î© = gmsh.model.geo.addPlaneSurface([1],1)
    gmsh.model.geo.synchronize()

    gmsh.model.addPhysicalGroup(1, [1], -1, "Î“Â¹")
    gmsh.model.addPhysicalGroup(1, [2], -1, "Î“Â²")
    gmsh.model.addPhysicalGroup(1, [3], -1, "Î“Â³")
    gmsh.model.addPhysicalGroup(1, [4], -1, "Î“â´")
    gmsh.model.addPhysicalGroup(2, [Î©], -1, "Î©")

    return Î©
end
end